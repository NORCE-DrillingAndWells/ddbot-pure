{
    "Interpret_mnemonic": {
        "default": "v2",
        "v1": "Split the provided mnemonic used in drilling domain into meaningful components and interpret the meaning of them, assuming the mnemonic as a combination of 'prefix', 'keyword' and 'suffix'. The returned result should be formatted like 'keyword: meaning', and do not include any other things. Some references are as follows: 1. Split the mnemonic by special symbol like '_', '#', and parse each part separately. 2. The number as a suffix often means the index of the series data channel, such as 'SPM2' means the 2nd SPM data. 3. The combination of number and a time unit as a suffix often means a data filter, such as 'RPM30s' means the average RPM during 30 seconds. 4. Check if the mnemonic contains strings as prefix and keyword in the complementary knowledge. 5. According the description, interpret the mnemonic part-wise. For example, according to 'Total Hookload', 'THKD' can be splitted into '{T:Total, HKD: Hookload}'. According to 'MudPit Volume Average 9', 'GS_TV09' can be splitted into '{GS:GeoService, TV: tank volume, 09: index 9}'. 6. Some complementary knowledge are {<complementary_knowledge>} 7. Use your drilling knowledge to interpret if possible. The user query is '{<user_query>}'",
        "v2": "Task Objective: Split the provided mnemonic used in the drilling domain into meaningful components, interpret the meaning of each component. Do it step by step strictly: 1. Split the mnemonic by special symbol like '_', '#'. 2. Consider to split the mnemonic if there is a number suffix. It often means the index of the series data channel, such as 'SPM2' means 'the 2nd SPM data'. But the number can also be part of a name, such as 'C3' can mean 'Propane'. 3. Split the mnemonic if it includes a combination of a number and a time unit as a suffix. This often represents a data filter, e.g., RPM30s means 'the average RPM over 30 seconds'. 4. Split the mnemonic if it includes strings as prefix and keyword from the complementary knowledge. 5. Consider to split the mnemonic if some parts of the mnemonic can be considered as shorthand for drilling terms. For example, 'THKD' can be splitted into 'T' and 'HKD', as 'HKD' can be a drilling term 'Hookload'. 6. Interpret the mnemonic component by component using both the unit and the text description, including all components. If a component is not understandable, use 'undefined'. For example, according to 'Total Hookload, kkgf', 'THKD' can be interpreted as '{T:Total, HKD: Hookload}'. According to 'MudPit Volume Average 9, m3', 'GS_TV09' can be interpreted as '{GS:GeoService, TV: tank volume, 09: index 9}'. 7. Provide some short remarks, e.g., if the unit is 'm', the physical quantity can be 'Length' or 'Depth'; if the unit is 'm/s', it can be a 'Velocity'. Input: User query: {<user_query>}. Complementary knowledge: {<complementary_knowledge>}. Output: Return the result in the format: {'mnemonic component 1': meaning, 'mnemonic component 2': meaning, ..., Remark: Remarks}, without any explanation or additional information. For example, 'THKD' can be interpreted as '{T:Total, HKD: Hookload, Remark:ForceQuantity}'."
    },
    "Preselect_quantity": {
        "default": "v2",
        "v1": "Instructions: You will receive a user input containing mnemonic-based metadata used in the drilling domain. Preselect the quantities related to the metadata from the provided list, especially considering the unit. An interpretation will be provided for your reference, but its correctness is not guaranteed. Some complementary knowledge are {<complementary_knowledge>}. Input: User input: {<user_query>}. Interpretation: {<interpretation>}. Quantity list: {<selection_range>}. Output: Return the top 3 selected quantities only, formatted as 'item1, item2, item3', without any explanation or additional information. The selected items must be from the provided list. If no match or less than 3 matches are found, use 'None' as a placeholder.",
        "v2": "Task Objective: Based on mnemonic-based metadata in user query used in the drilling domain, accurately preselect the top 3 most relevant quantities from a provided list. Do it step by step: 1. Unit Matching (Priority 1): Find the `Unit` field in user query, and match the related quantities in the provided list. 2. Semantic Matching (Priority 2): Understand the mnemonic with the help of `Description`, `Interpretation` and 'complementary knowledge' using your own drilling knowledge, and match the related quantities from the remaining list. `Interpretation` is useful reference. The LLM's interpretation is helpful but not guaranteed, whereas the user's interpretation is trustworthy if it exists. 3. Exclude (Priority 0): If the quantity selected in the above steps is not in the list provided, it is firmly excluded. 4. Return the matched quantities after the above steps. Input: User query: {<user_query>}. Interpretation: {<interpretation>}. Quantity list: {<selection_range>}. Complementary knowledge: {<complementary_knowledge>} Output: Return the top 3 selected quantities only, without any explanation or additional information. Hard Constraints: 1. Outputs **must** use **exact names** from the provided list. 2. Use `None` as a placeholder if fewer than 3 matches exist. Maintain strict `item1,item2,item3` format."
    },
    "Preselect_unit": {
        "default": "v2",
        "v1": "Instructions: You will receive a user input containing mnemonic-based metadata used in the drilling domain. Preselect the units related to the metadata from the provided list. An interpretation will be provided for your reference, but its correctness is not guaranteed. Some complementary knowledge are {<complementary_knowledge>}. Input: User input: {<user_query>}. Interpretation: {<interpretation>}. Unit list: {<selection_range>}. Output: Return the top 5 selected units only, formatted as 'item1, item2,..., item5', without any explanation or additional information. The selected items must be from the provided list. If no match or less than 5 matches are found, use 'None' as a placeholder.",
        "v2": "Task Objective: Based on mnemonic-based metadata in user query used in the drilling domain, accurately preselect the top 5 most relevant units from a provided list. Do it step by step: 1. Unit Matching (Priority 1): Find the `Unit` field in user query, and match the related quantities in the provided list. 2. Semantic Matching (Priority 2): Understand the mnemonic with the help of `Description`, `Interpretation` and 'complementary knowledge' using your own drilling knowledge, and match the related units from the remaining list. `Interpretation` is useful reference. The LLM's interpretation is helpful but not guaranteed, whereas the user's interpretation is trustworthy if it exists. 3. Exclude (Priority 0): If the unit selected in the above steps is not in the list provided, it is firmly excluded. 4. Return the matched units after the above steps. Input: User query: {<user_query>}. Interpretation: {<interpretation>}. Unit list: {<selection_range>}. Complementary knowledge: {<complementary_knowledge>} Output: Return the top 5 selected units only, without any explanation or additional information. Hard Constraints: 1. Outputs **must** use **exact names** from the provided list. 2. Use `None` as a placeholder if fewer than 5 matches exist. Maintain strict `item1,item2,...,item5` format."
    },
    "Preselect_prototypeData": {
        "default": "v3",
        "v1": "Instructions: You will receive a user input containing mnemonic-based metadata used in the drilling domain. Preselect the prototypeData related to the metadata from the provided list. An interpretation will be provided for your reference, but its correctness is not guaranteed. Some complementary knowledge are {<complementary_knowledge>}. Input: User input: {<user_query>}. Interpretation: {<interpretation>}. PrototypeData list: {<selection_range>}. Output: Return the top 3 selected prototypeData only, formatted as 'item1, item2, item3', without any explanation or additional information. The selected items must be from the provided list. If no match or less than 3 matches are found, use 'None' as a placeholder.",
        "v2": "Task Objective: Based on mnemonic-based metadata in user query used in the drilling domain, accurately preselect the top 3 most relevant prototypeData from a provided list. Do it step by step: 1. Direct Matching (Priority 1): It is a strong match if the mnemonic or part of the mnemonic can be found in `complementary knowledge`. The `Interpretation` is a useful reference to understand the mnemonic. The LLM's interpretation is helpful but not guaranteed, whereas the user's interpretation is trustworthy if it exists. 2. Semantic Matching (Priority 2): Understand the mnemonic with the help of `Description`, 'complementary knowledge' and `Interpretation` using your own drilling knowledge, and match the related prototypeData from the list. 3. Exclude (Priority 0): If the unit selected in the above steps is not in the list provided, it is firmly excluded. 4. Return the matched units after the above steps. Input: User query: {<user_query>}. Interpretation: {<interpretation>}. PrototypeData list: {<selection_range>}. Complementary knowledge: {<complementary_knowledge>} Output: Return the top 3 selected prototypeData only, without any explanation or additional information. Hard Constraints: 1. Outputs **must** use **exact names** from the provided list. 2. Use `None` as a placeholder if fewer than 3 matches exist. Maintain strict `item1,item2,item3` format.",
        "v3": "Task Objective: Based on mnemonic-based metadata in user query used in the drilling domain, accurately preselect the top 3 most relevant prototypeData from a provided list. Do it step by step: 1. Direct Matching (Priority 1): It is a strong match if the mnemonic or part of the mnemonic can be found in `complementary knowledge`. The `Interpretation` is a useful reference to understand the mnemonic. The LLM's interpretation is helpful but not guaranteed, whereas the user's interpretation is trustworthy if it exists. 2. Semantic Matching (Priority 2): Analyze the mnemonic using `Description`, `complementary knowledge`, and `Interpretation`. Pay special attention to synonyms and related terms. Ensure to consider all relevant terms that may relate to the user's query, especially those that describe similar concepts or functions. 3. Exclude (Priority 0): If the unit selected in the above steps is not in the list provided, it is firmly excluded. 4. Return the matched units after the above steps. Input: User query: {<user_query>}. Interpretation: {<interpretation>}. PrototypeData list: {<selection_range>}. Complementary knowledge: {<complementary_knowledge>} Output: Return the top 3 selected prototypeData only, without any explanation or additional information. Hard Constraints: 1. Outputs **must** use **exact names** from the provided list. 2. Use `None` as a placeholder if fewer than 3 matches exist. Maintain strict `item1,item2,item3` format."
    },
    "Recognize_quantity": {
        "default": "v2",
        "v1": "Instructions: You will receive a user input containing mnemonic-based metadata used in the drilling domain. Recognize the quantity related to the metadata from the provided list. An interpretation will be provided for your reference, but its correctness is not guaranteed. Some complementary knowledge are {<complementary_knowledge>}. Input: User input: {<user_query>}. Interpretation: {<interpretation>}. Quantity list: {<selection_range>}. Output: Return the top 1 selected quantity, only the name, without any explanation or additional information. The selected item must be from the provided list. If no match is found, use 'None' as a placeholder.",
        "v2": "Task Objective: Based on mnemonic-based metadata in user query used in the drilling domain, select the best matching quantity from a provided list. Do it step by step: 1. Unit Matching (Priority 1): Find the `Unit` field in user query, and match the related quantities in the provided list. 2. Semantic Matching (Priority 2): Understand the mnemonic with the help of `Description`, `Interpretation` and 'complementary knowledge' using your own drilling knowledge, and match the related quantities from the remaining list. `Interpretation` is useful reference. The LLM's interpretation is helpful but not guaranteed, whereas the user's interpretation is trustworthy if it exists. 3. Exclude (Priority 0): If the quantity selected in the above steps is not in the list provided, it is firmly excluded. 4. Select the best match from the quantities left after the above steps. Input: User query: {<user_query>}. Interpretation: {<interpretation>}. Quantity list: {<selection_range>}. Complementary knowledge: {<complementary_knowledge>} Output: Return only 1 best matching quantity name, without any explanation or additional information. Hard Constraints: 1. Output must use exact name from the provided list. 2. Return only the value of 'ddhub:Quantity' field, without the key name. For example, `ForceQuantity`, not `ddhub:Quantity:ForceQuantity`. 3. Use `None` as a placeholder if no matches exist."
    },
    "Recognize_unit": {
        "default": "v2",
        "v1": "Instructions: You will receive a user input containing mnemonic-based metadata used in the drilling domain. Recognize the unit related to the metadata from the provided list. An interpretation will be provided for your reference, but its correctness is not guaranteed. Some complementary knowledge are {<complementary_knowledge>}. Input: User input: {<user_query>}. Interpretation: {<interpretation>}. Unit list: {<selection_range>}. Output: Return the top 1 selected unit, only the name, without any explanation or additional information. The selected item must be from the provided list. If no match is found, use 'None' as a placeholder.",
        "v2": "Task Objective: Based on mnemonic-based metadata in user query used in the drilling domain, select the best matching unit from a provided list. Do it step by step: 1. Unit Matching (Priority 1): Find the `Unit` field in user query, and match the related quantities in the provided list. 2. Semantic Matching (Priority 2): Understand the mnemonic with the help of `Description`, 'complementary knowledge' and `Interpretation` using your own drilling knowledge, and match the related prototypeData from the list. `Interpretation` is useful reference. The LLM's interpretation is helpful but not guaranteed, whereas the user's interpretation is trustworthy if it exists. 3. Exclude (Priority 0): If the unit selected in the above steps is not in the list provided, it is firmly excluded. 4. Select the best match from the units left after the above steps. Input: User query: {<user_query>}. Interpretation: {<interpretation>}. Unit list: {<selection_range>}. Complementary knowledge: {<complementary_knowledge>} Output: Return only 1 best matching unit name, without any explanation or additional information. Hard Constraints: 1. Output must use exact name from the provided list. 2. Return only the value of 'ddhub:Unit' field, without the key name. For example, `newton`, not `ddhub:Unit:newton`. 3. Use `None` as a placeholder if no matches exist."
    },
    "Recognize_prototypeData": {
        "default": "v2",
        "v1": "Instructions: You will receive a user input containing mnemonic-based metadata used in the drilling domain. Recognize the prototypeData related to the metadata from the provided list. An interpretation will be provided for your reference, but its correctness is not guaranteed. Some complementary knowledge are {<complementary_knowledge>}. Input: User input: {<user_query>}. Interpretation: {<interpretation>}. PrototypeData list: {<selection_range>}. Output: Return the top 1 selected prototypeData, only the name, without any explanation or additional information. The selected item must be from the provided list. If no match is found, use 'None' as a placeholder.",
        "v2": "Task Objective: Based on mnemonic-based metadata in user query used in the drilling domain, select the best matching prototypeData from a provided list. Check the prototypeData in the provided list one by one and step by step: 1. Identify the 'ddhub:IsOfMeasurableQuantity' of the DDHub PrototypeData.  2. Check if the unit of the user query is a possible unit of 'ddhub:IsOfMeasurableQuantity'. If not, rule out this PrototypeData.  3. It is a strong match if this prototypeData can explain the mnemonic of user query according to complementary knowledge. 4. Understand the meaning of user query according to the description, interpretation, complementary knowledge, and compare with the other PrototypeData one by one. `Interpretation` is useful reference. The LLM's interpretation is helpful but not guaranteed, whereas the user's interpretation is trustworthy if it exists. 5. Exclude: If the prototypeData selected in the above steps is not in the list provided, it is firmly excluded. 6. Select the best match from the prototypeData left after the above steps. Input: User query: {<user_query>}. Interpretation: {<interpretation>}. PrototypeData list: {<selection_range>}. Complementary knowledge: {<complementary_knowledge>} Output: Return only 1 best matching prototypeData name, without any explanation or additional information. Hard Constraints: 1. Output must use exact name from the provided list. 2. Return only the value of 'ddhub:PrototypeData' field, without the key name. For example, `WOB`, not `ddhub:PrototypeData:WOB`. 3. Use `None` as a placeholder if no matches exist."
    },
    "Interpret_quantity_unit": {
        "default": "v1",
        "v1": "Instructions: You will receive a user input containing mnemonic-based metadata used in the drilling domain. Identify the quantity related to the metadata from the provided candidates. An interpretation will be provided for your reference, but its correctness is not guaranteed. Some complementary knowledge are {<complementary_knowledge>}. Input: User input: {<user_query>}. Interpretation: {<interpretation>}. Quantity candidates: {<selection_range>}. Output: Return the top 3 selected quantity only, formatted as 'item1, item2, item1', without any explanation or additional information."
    },
    "PrototypeData": {
        "default": "v9",
        "v1": "The user input will contain a mnemonic and its description, along with possible additional information like units. Each mnemonic should be mapped to a DDHubName. Your task is to parse the mnemonic from the user input based on the provided description and naming conventions, such as 'mnemonic', 'Description', 'LongMnemonic', or 'ShortMnemonic'. Reference other files with mnemonics and their descriptions as needed. Ensure that the output is one of the DDHubNames listed in the DDHubNames JSON file. If a matching DDHubName is found, output it along with your confidence level (low, medium, high) in the format 'DDHubName, high'. If no match is found, output 'None, low'. Do not include any extraneous information.",
        "v2": "Your task is to parse the metadata from the user input and map it to the best matching one from DDHubNames. Ensure that the output is one of the DDHubNames provided, only the part before ':'. If no match is found, output 'None'. Do not include any extraneous information. The user input is the mnemonic-based metadata, containing mnemonic and its description, along with possible additional information like units. The user input to parse is '''{user_query}''', and the related DDHubNames are '''{relatedContext}'''.",
        "v3": "You are a classifier. Your task is to parse the metadata from the user query and map it to the best matching one from provided DDHub PrototypeData. Ensure that the output is one of the DDHub PrototypeData provided, only the value of 'ddhub:PrototypeData'. If no match is found, output 'None'. Do not include any extraneous information. The user query is the mnemonic-based metadata, containing mnemonic and its description, along with possible additional information like units. The user query to parse is '{user_query}', and the related DDHub PrototypeData are '{relatedContext}'.",
        "v4": "You are a classifier. Your task is to parse the metadata from the user query and return the top 3 best matching entries from the provided DDHub PrototypeData. The top 3 matches should have the highest similarity to the input user query. Your output should be formatted as 'PrototypeData1, PrototypeData2, PrototypeData3'. Ensure that the output consists only of the values from 'ddhub:PrototypeData'. If no match is found, output 'None'. Do not include any extraneous information. The user query is mnemonic-based metadata, containing a mnemonic and its description, along with possible additional information like units. The user query to parse is '{user_query}', and the related DDHub PrototypeData are '{relatedContext}'.",
        "v5": "You are a classifier. Your task is to parse the metadata from the user query and return the top 3 best matching entries from the provided DDHub PrototypeData. The user query is mnemonic-based metadata, containing a mnemonic and its description, along with possible additional information like unit. Follow these steps to decide: 1. Find 5 similar DDHub PrototypeData; 2. Identify the 'ddhub:IsOfMeasurableQuantity' of these DDHub PrototypeData; 3. Check if the unit in the user query is a possible unit of 'ddhub:IsOfMeasurableQuantity'. If no, rule out this DDHub PrototypeData; 4. Return the top 3 matches with the highest similarity to the input user query. Your output should be formatted as 'PrototypeData1, PrototypeData2, PrototypeData3'. Ensure that the output consists only of the values from 'ddhub:PrototypeData'. If no match is found, output 'None'. Do not include any extraneous information. The user query to parse is '{user_query}', and the related DDHub PrototypeData candidates are '{relatedContext}'.",
        "v6": "Your task is to parse the metadata from the user query and return the top 3 best matching entries from the provided DDHub PrototypeData. The user query is mnemonic-based metadata, containing a mnemonic and its description, and possible additional information like unit. Follow these steps to decide: 1. Identify the 'ddhub:IsOfMeasurableQuantity' of these DDHub PrototypeData; 2. Check if the unit in the user query is a possible unit of 'ddhub:IsOfMeasurableQuantity'. If not, rule out this DDHub PrototypeData; 3. Consider the mnemonic as a combination of 'prefix', 'keyword' and 'suffix', and try to split it into meaningful components. Examples of 'keyword' are 'WOB', 'ROP', 'SPP', 'SPM', 'RPM'. Examples of 'prefix' and 'suffix' are 'A' for average, '30S' for '30 second', '09' for an index. Symbol '_' is usually used to connect different components. For example, interpret 'RPM30s' as 'RPM' and '30s', and 'GS_TV09' as 'GS', 'TV', and '09'; 4. Understand the meaning of user input based on the description and mnemonic components, and compare with the remaining PrototypeData one by one; 5. Return the top 3 matching PrototypeData with the highest similarity to the input user query. Your output should be formatted as 'PrototypeData1, PrototypeData2, PrototypeData3'. Ensure that the output consists only of the values from 'ddhub:PrototypeData'. If no match or less than 3 matches are found, use 'None' as a placeholder. Do not include any extraneous information. The user query to parse is '{user_query}', and the related DDHub PrototypeData candidates are '{relatedContext}'.",
        "v7": "Your task is to parse the metadata from the user query and return the top 3 best matching entries from the provided DDHub PrototypeData. The user query is mnemonic-based metadata, containing a mnemonic and its description, and possible additional information like unit. Follow these steps to decide: 1. Identify the 'ddhub:IsOfMeasurableQuantity' of these DDHub PrototypeData. 2. Check if the unit in the user query is a possible unit of 'ddhub:IsOfMeasurableQuantity'. If not, rule out this DDHub PrototypeData. 3. Understand the meaning of user input according to the description, interpretation, complementary knowledge, and compare with the remaining PrototypeData one by one. 4. Return the top 3 matching PrototypeData with the highest similarity to the input user query. Your output should be formatted as 'PrototypeData1, PrototypeData2, PrototypeData3'. Ensure that the output consists only of the values from 'ddhub:PrototypeData'. If no match or less than 3 matches are found, use 'None' as a placeholder. Do not include any extraneous information. The user query to parse is '{user_query}', the related DDHub PrototypeData candidates are '{relatedContext}', and the interpretation is '{Interpretation}'. Some complementary knowledge is {RPM means SurfaceRPM not DownholeRPM unless specified. SPM is a type of PumpRate in DDHub PrototypeData.} ",
        "v8": "Your task is to parse the metadata from the user query and return the top 3 best matching entries from the provided DDHub PrototypeData. The user query is mnemonic-based metadata, containing a mnemonic and its description, and possible additional information like unit. Follow these steps to decide: 1. Identify the 'ddhub:IsOfMeasurableQuantity' of these DDHub PrototypeData. 2. Check if the unit in the user query is a possible unit of 'ddhub:IsOfMeasurableQuantity'. If not, rule out this DDHub PrototypeData. 3. Understand the meaning of user input according to the description, interpretation, complementary knowledge, and compare with the remaining PrototypeData one by one. 4. Return the top 3 matching PrototypeData with the highest similarity to the input user query. Your output should be formatted as 'PrototypeData1, PrototypeData2, PrototypeData3'. Ensure that the output consists only of the values from 'ddhub:PrototypeData'. If no match or less than 3 matches are found, use 'None' as a placeholder. Do not include any extraneous information. The user query to parse is '{user_query}', the related DDHub PrototypeData candidates are '{relatedContext}', and the interpretation is '{Interpretation}'. Some complementary knowledge is {SPP: Stand Pipe Pressure. SPM: Strokes Per Minutes, SPM is PumpRate, which is FrequencyQuantity. RPM: Revolutions Per Minute. RPM means SurfaceRPM not DownholeRPM unless specified. It is FrequencyQuantity not AngularVelocityQuantity. DRPM: Downhole RPM. ROP: Rate of Penetration. GS: GeoService. SRV: Survey. HKLD: Hookload. HKD: Hookload. POS: Position. WOB: Weight of Bit. SWOB: Surface Weight of Bit. TV: Tank volume. TQ: Torque. TQ is SurfaceTorque not DownholeTorque unless specified. WT: Weight. MPD: Managed pressure drilling. MD: Measured depth. TVD: True vertical depth. When a depth is not specified to be TVD, it is usually measured depth. A: Sometimes means 'Average' in a mnemonic.}",
        "v9": "Task Objective: Based on mnemonic-based metadata in user query used in the drilling domain, select the best matching prototypeData from a provided candidate list. Do it step by step strictly: 1. Unit Matching (Find relevant matches): For each candidate in the candidate list, check if the unit of the user query is a possible unit of 'ddhub:IsOfBaseQuantity' of each candidate. If not, rule out this PrototypeData. If yes or unsure, include it in a matching list. 2. Semantic Matching (Find strong matches): For each candidate in the matching list, if it can explain the mnemonic or part of the mnemonic according to `complementary knowledge`, mark it as a strong match. 3. Semantic Exclusion: For each candidate in the matching list, use the Description, Interpretation, and Complementary knowledge, and your own drilling knowledge, to check if the candidate aligns with the meaning of mnemonic in user query. If the candidate is impossible and unsure, exclude it from the matching list. Note that the user's interpretation is trustworthy if it exists, while the LLM's interpretation could be helpful but not guaranteed. 4. Select the top 3 best match from the matching list, especially considering the strong matches. 5. Relevance recheck: Double check if the selected is relevant. If it is not perfect match, just return 'None' as placeholder. 'None' is better than a wrong match. 6. Name recheck (Priority 0): Ensure the selected candidate is from the provided candidate list, using the exact name as given. The name is the value of 'ddhub:PrototypeData' field, without the key name. For example, `WOB`, not `ddhub:WOB`. 7. Return the top 3 matching PrototypeData, formatted as 'PrototypeData1, PrototypeData2, PrototypeData3', without any explanation or additional information. The user query to parse is '{user_query}', the related DDHub PrototypeData candidates are '{relatedContext}', and the interpretation is '{Interpretation}'. Some complementary knowledge is {SPP: Stand Pipe Pressure. SPM: Strokes Per Minutes, SPM is PumpRate, which is FrequencyQuantity. RPM: Revolutions Per Minute. RPM means SurfaceRPM not DownholeRPM unless specified. It is FrequencyQuantity not AngularVelocityQuantity. DRPM: Downhole RPM. ROP: Rate of Penetration. GS: GeoService. SRV: Survey. HKLD: Hookload. HKD: Hookload. POS: Position. WOB: Weight of Bit. SWOB: Surface Weight of Bit. TV: Tank volume. TQ: Torque. TQ is SurfaceTorque not DownholeTorque unless specified. WT: Weight. MPD: Managed pressure drilling. MD: Measured depth. TVD: True vertical depth. When a depth is not specified to be TVD, it is usually measured depth. A: Sometimes means 'Average' in a mnemonic. kkgf: kilo kilogram force, or thousand kilogram force, or ton force.}"
    },
    "Unit": {
        "default": "v4",
        "v1": "Your task is to parse the metadata from the user query and return the top 3 best matching entries from the provided DDHub Unit candidates. The user query is mnemonic-based metadata, containing a unit, a mnemonic and its description, along with possible additional information. Follow these steps to decide: 1. Identify 'Unit' and 'Quantity_class' in the user query; 2. Find 5 similar DDHub Unit in 'Unit_candidates'; 3. Check if each of these 5 units is a possible unit for 'Quantity_class'. If not, rule out this DDHub Unit; 4. Return the top 3 matches with the highest similarity to the unit in the input user query. Your output should be formatted as 'Unit1, Unit2, Unit3'. Ensure that the output consists only of the values from 'Unit_candidates'. If no match is found, output 'None'. Do not include any extraneous information. The user query to parse is '{user_query}', and the DDHub Unit candidates are '{relatedContext}'.",
        "v2": "Your task is to parse the metadata from the user query and return the top 3 best matching entries from the provided DDHub Unit candidates. The user query is mnemonic-based metadata, containing a unit, a mnemonic and its description, along with possible additional information. Follow these steps to decide: 1. Identify 'Unit' and 'Quantity_class' in the user query; 2. Check if each of these units is a possible unit for 'Quantity_class'. If not, rule out this DDHub Unit; 3. Return the top 3 matches with the highest similarity to the unit in the input user query. Your output should be formatted as 'Unit1, Unit2, Unit3'. Ensure that the output consists only of the values from 'Unit_candidates'. If no match or less than 3 matches are found, use 'None' as placeholder. Do not include any extraneous information. The user query to parse is '{user_query}', and the DDHub Unit candidates are '{relatedContext}'.",
        "v3": "Your task is to parse the metadata from the user query and return the top 3 best matching entries from the provided DDHub Unit candidates. The user query is mnemonic-based metadata, containing a unit, a mnemonic and its description, along with possible additional information. Follow these steps to decide: 1. Identify 'Unit' and 'Quantity_class' in the user query; 2. Check if each of these units is a possible unit for 'Quantity_class'. If not, rule out this DDHub Unit; 3. Return the top 3 matches with the highest similarity to the unit in the input user query. Your output should be formatted as 'Unit1, Unit2, Unit3'. Ensure that the output consists only of the values from 'Unit_candidates'. If no match or less than 3 matches are found, use 'None' as placeholder. Do not include any extraneous information. The user query to parse is '{user_query}', and the DDHub Unit candidates are '{relatedContext}', and the interpretation is '{Interpretation}'.",
        "v4": "Task Objective: Based on mnemonic-based metadata in user query used in the drilling domain, select the best matching unit from a provided list. Do it step by step strictly: 1. Semantic Matching (Find relevant matches): Use the Description, Interpretation, and Complementary knowledge, along with your own drilling knowledge, to check if a candidate unit is relevant with the user query. If yes, include this candidate in a matching list. Note that the user's interpretation is trustworthy if it exists, while the LLM's interpretation could be helpful but not guaranteed. 2. Direct Matching (Find strong matches): For each candidate in the candidate list, compare the `ddhub:Unit` field of a candidate and the `Unit` field in user query. If they are semantically similar, include this candidate in a matching list and mark it as a strong match. Note that the 2 units from the candidate and user query do not have to be identical, as long as they are semantically similar. For example, 'm/s' and 'meterPerSecond' are semantically similar. 3. Select the top 3 best match from the matching list, especially considering the strong matches. 4. Relevance recheck: Double check if the selected is relevant. If it is not relevant in any sense, just return 'None' as placeholder. 5. Name recheck (Priority 0): Ensure the selected candidate is from the provided candidate list, using the exact name as given. The name is the value of 'ddhub:Unit' field, without the key name. For example, `newton`, not `ddhub:newton` nor `ddhub:Unit newton`. 6. Return the top 3 matches, formatted as 'Unit1, Unit2, Unit3', without any explanation or additional information. The user query to parse is '{user_query}', and the DDHub Unit candidates are '{relatedContext}', and the interpretation is '{Interpretation}'. Some complementary knowledge is {SPP: Stand Pipe Pressure. SPM: Strokes Per Minutes, SPM is PumpRate, which is FrequencyQuantity. RPM: Revolutions Per Minute. RPM means SurfaceRPM not DownholeRPM unless specified. It is FrequencyQuantity not AngularVelocityQuantity. DRPM: Downhole RPM. ROP: Rate of Penetration. GS: GeoService. SRV: Survey. HKLD: Hookload. HKD: Hookload. POS: Position. WOB: Weight of Bit. SWOB: Surface Weight of Bit. TV: Tank volume. TQ: Torque. TQ is SurfaceTorque not DownholeTorque unless specified. WT: Weight. MPD: Managed pressure drilling. MD: Measured depth. TVD: True vertical depth. When a depth is not specified to be TVD, it is usually measured depth. A: Sometimes means 'Average' in a mnemonic. kkgf: kilo kilogram force, or thousand kilogram force, or ton force.}"
    },
    "other_processing": {
        "default": "...",
        "v1": "..."
    },
    "complementary_knowledge": {
        "default": "v1",
        "v1": {
            "SPP": "Stand Pipe Pressure.",
            "SPM": "Strokes Per Minutes, SPM is a type of PumpRate, which is FrequencyQuantity.",
            "RPM": "Revolutions Per Minute. RPM means SurfaceRPM not DownholeRPM unless specified. It is FrequencyQuantity not AngularVelocityQuantity.",
            "DRPM": "Downhole RPM.",
            "ROP": "Rate of Penetration.",
            "GS": "GeoService.",
            "SRV": "Survey.",
            "HKLD": "Hookload.",
            "HKD": "Hookload.",
            "POS": "Position.",
            "WOB": "Weight of Bit.",
            "SWOB": "Surface Weight of Bit.",
            "TV": "Tank volume.",
            "TQ": "Torque. TQ is SurfaceTorque not DownholeTorque unless specified.",
            "WT": "Weight.",
            "MPD": "managed pressure drilling",
            "MD": "Measured depth",
            "TVD": "True vertical depth"
        }
    }
}